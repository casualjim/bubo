// Code generated by mockery v2.50.1. DO NOT EDIT.

package mocks

import (
	context "context"

	messages "github.com/casualjim/bubo/messages"

	mock "github.com/stretchr/testify/mock"
)

// Hook is an autogenerated mock type for the Hook type
type Hook struct {
	mock.Mock
}

type Hook_Expecter struct {
	mock *mock.Mock
}

func (_m *Hook) EXPECT() *Hook_Expecter {
	return &Hook_Expecter{mock: &_m.Mock}
}

// OnAssistantChunk provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnAssistantChunk(_a0 context.Context, _a1 messages.Message[messages.AssistantMessage]) {
	_m.Called(_a0, _a1)
}

// Hook_OnAssistantChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAssistantChunk'
type Hook_OnAssistantChunk_Call struct {
	*mock.Call
}

// OnAssistantChunk is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.AssistantMessage]
func (_e *Hook_Expecter) OnAssistantChunk(_a0 interface{}, _a1 interface{}) *Hook_OnAssistantChunk_Call {
	return &Hook_OnAssistantChunk_Call{Call: _e.mock.On("OnAssistantChunk", _a0, _a1)}
}

func (_c *Hook_OnAssistantChunk_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.AssistantMessage])) *Hook_OnAssistantChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.AssistantMessage]))
	})
	return _c
}

func (_c *Hook_OnAssistantChunk_Call) Return() *Hook_OnAssistantChunk_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnAssistantChunk_Call) RunAndReturn(run func(context.Context, messages.Message[messages.AssistantMessage])) *Hook_OnAssistantChunk_Call {
	_c.Run(run)
	return _c
}

// OnAssistantMessage provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnAssistantMessage(_a0 context.Context, _a1 messages.Message[messages.AssistantMessage]) {
	_m.Called(_a0, _a1)
}

// Hook_OnAssistantMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAssistantMessage'
type Hook_OnAssistantMessage_Call struct {
	*mock.Call
}

// OnAssistantMessage is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.AssistantMessage]
func (_e *Hook_Expecter) OnAssistantMessage(_a0 interface{}, _a1 interface{}) *Hook_OnAssistantMessage_Call {
	return &Hook_OnAssistantMessage_Call{Call: _e.mock.On("OnAssistantMessage", _a0, _a1)}
}

func (_c *Hook_OnAssistantMessage_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.AssistantMessage])) *Hook_OnAssistantMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.AssistantMessage]))
	})
	return _c
}

func (_c *Hook_OnAssistantMessage_Call) Return() *Hook_OnAssistantMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnAssistantMessage_Call) RunAndReturn(run func(context.Context, messages.Message[messages.AssistantMessage])) *Hook_OnAssistantMessage_Call {
	_c.Run(run)
	return _c
}

// OnError provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnError(_a0 context.Context, _a1 error) {
	_m.Called(_a0, _a1)
}

// Hook_OnError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnError'
type Hook_OnError_Call struct {
	*mock.Call
}

// OnError is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 error
func (_e *Hook_Expecter) OnError(_a0 interface{}, _a1 interface{}) *Hook_OnError_Call {
	return &Hook_OnError_Call{Call: _e.mock.On("OnError", _a0, _a1)}
}

func (_c *Hook_OnError_Call) Run(run func(_a0 context.Context, _a1 error)) *Hook_OnError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(error))
	})
	return _c
}

func (_c *Hook_OnError_Call) Return() *Hook_OnError_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnError_Call) RunAndReturn(run func(context.Context, error)) *Hook_OnError_Call {
	_c.Run(run)
	return _c
}

// OnToolCallChunk provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnToolCallChunk(_a0 context.Context, _a1 messages.Message[messages.ToolCallMessage]) {
	_m.Called(_a0, _a1)
}

// Hook_OnToolCallChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnToolCallChunk'
type Hook_OnToolCallChunk_Call struct {
	*mock.Call
}

// OnToolCallChunk is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.ToolCallMessage]
func (_e *Hook_Expecter) OnToolCallChunk(_a0 interface{}, _a1 interface{}) *Hook_OnToolCallChunk_Call {
	return &Hook_OnToolCallChunk_Call{Call: _e.mock.On("OnToolCallChunk", _a0, _a1)}
}

func (_c *Hook_OnToolCallChunk_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.ToolCallMessage])) *Hook_OnToolCallChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.ToolCallMessage]))
	})
	return _c
}

func (_c *Hook_OnToolCallChunk_Call) Return() *Hook_OnToolCallChunk_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnToolCallChunk_Call) RunAndReturn(run func(context.Context, messages.Message[messages.ToolCallMessage])) *Hook_OnToolCallChunk_Call {
	_c.Run(run)
	return _c
}

// OnToolCallMessage provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnToolCallMessage(_a0 context.Context, _a1 messages.Message[messages.ToolCallMessage]) {
	_m.Called(_a0, _a1)
}

// Hook_OnToolCallMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnToolCallMessage'
type Hook_OnToolCallMessage_Call struct {
	*mock.Call
}

// OnToolCallMessage is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.ToolCallMessage]
func (_e *Hook_Expecter) OnToolCallMessage(_a0 interface{}, _a1 interface{}) *Hook_OnToolCallMessage_Call {
	return &Hook_OnToolCallMessage_Call{Call: _e.mock.On("OnToolCallMessage", _a0, _a1)}
}

func (_c *Hook_OnToolCallMessage_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.ToolCallMessage])) *Hook_OnToolCallMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.ToolCallMessage]))
	})
	return _c
}

func (_c *Hook_OnToolCallMessage_Call) Return() *Hook_OnToolCallMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnToolCallMessage_Call) RunAndReturn(run func(context.Context, messages.Message[messages.ToolCallMessage])) *Hook_OnToolCallMessage_Call {
	_c.Run(run)
	return _c
}

// OnToolCallResponse provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnToolCallResponse(_a0 context.Context, _a1 messages.Message[messages.ToolResponse]) {
	_m.Called(_a0, _a1)
}

// Hook_OnToolCallResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnToolCallResponse'
type Hook_OnToolCallResponse_Call struct {
	*mock.Call
}

// OnToolCallResponse is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.ToolResponse]
func (_e *Hook_Expecter) OnToolCallResponse(_a0 interface{}, _a1 interface{}) *Hook_OnToolCallResponse_Call {
	return &Hook_OnToolCallResponse_Call{Call: _e.mock.On("OnToolCallResponse", _a0, _a1)}
}

func (_c *Hook_OnToolCallResponse_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.ToolResponse])) *Hook_OnToolCallResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.ToolResponse]))
	})
	return _c
}

func (_c *Hook_OnToolCallResponse_Call) Return() *Hook_OnToolCallResponse_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnToolCallResponse_Call) RunAndReturn(run func(context.Context, messages.Message[messages.ToolResponse])) *Hook_OnToolCallResponse_Call {
	_c.Run(run)
	return _c
}

// OnUserPrompt provides a mock function with given fields: _a0, _a1
func (_m *Hook) OnUserPrompt(_a0 context.Context, _a1 messages.Message[messages.UserMessage]) {
	_m.Called(_a0, _a1)
}

// Hook_OnUserPrompt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUserPrompt'
type Hook_OnUserPrompt_Call struct {
	*mock.Call
}

// OnUserPrompt is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 messages.Message[messages.UserMessage]
func (_e *Hook_Expecter) OnUserPrompt(_a0 interface{}, _a1 interface{}) *Hook_OnUserPrompt_Call {
	return &Hook_OnUserPrompt_Call{Call: _e.mock.On("OnUserPrompt", _a0, _a1)}
}

func (_c *Hook_OnUserPrompt_Call) Run(run func(_a0 context.Context, _a1 messages.Message[messages.UserMessage])) *Hook_OnUserPrompt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(messages.Message[messages.UserMessage]))
	})
	return _c
}

func (_c *Hook_OnUserPrompt_Call) Return() *Hook_OnUserPrompt_Call {
	_c.Call.Return()
	return _c
}

func (_c *Hook_OnUserPrompt_Call) RunAndReturn(run func(context.Context, messages.Message[messages.UserMessage])) *Hook_OnUserPrompt_Call {
	_c.Run(run)
	return _c
}

// NewHook creates a new instance of Hook. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHook(t interface {
	mock.TestingT
	Cleanup(func())
},
) *Hook {
	mock := &Hook{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
